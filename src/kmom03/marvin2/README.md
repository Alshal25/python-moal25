
# python_moal25

# Redovisningstexter

# Kmom02 && Kmom03
![Marvin AI](../../../Marvin_image.png)


üêç Python b√∂rjar verkligen k√§nnas som ett riktigt kraftfullt spr√•k nu! Efter att ha g√•tt igenom b√•de kmom02 och kmom03 s√• ser jag hur spr√•ket utvecklas fr√•n enkla grunder till n√•got som faktiskt kan bygga komplexa, v√§lstrukturerade program. Trots att jag hade viss tidigare erfarenhet av funktioner och moduler fr√•n andra programmeringsspr√•k s√• blev √∂verg√•ngen fr√•n kmom02 till kmom03 √§nd√• en riktigt l√§rorik upplevelse. Det visade sig att det inte bara handlar om att kunna grunderna - det handlar om hur Python g√∂r saker p√• sitt eget s√§tt, och hur mycket funktioner och moduler f√∂r√§ndrar allt. Fr√•n en 180-raders monster-fil i kmom02 till tre organiserade filer i kmom03 d√§r varje funktion har sitt syfte. Jag f√∂rst√•r nu varf√∂r alla s√§ger att man ska dela upp koden - det √§r s√• mycket enklare att underh√•lla och hitta fel i. Random-modulen var kul att uppt√§cka, och string-metoder som index() √∂ppnade upp nya m√∂jligheter. Det mest givande var att se hur min tidigare kunskap kunde byggas ut och f√∂rfinas genom Python's eleganta approach.

üìú I kmom02 hade jag all kod i en enda stor fil och √§ven om Python-syntaxen k√§ndes logisk fr√•n b√∂rjan s√• blev strukturen r√∂rig n√§r komplexiteten √∂kade. F-strings som f"Hello {name}" var mycket smidigare √§n concatenation-metoder jag var van vid, och det som tog mest tid var att anpassa mig till indenteringen ist√§llet f√∂r krullparenteser. Jag byggde upp programmet med en stor while not stop: loop och massa if/elif/else f√∂r menyval, vilket fungerade f√∂r det momentet men jag m√§rkte redan d√• att det inte var h√•llbart i l√§ngden. De enklaste uppgifterna i kmom02 var greet-funktionaliteten och temperaturkonverteringen eftersom de bara kr√§vde grundl√§ggande input/output och enkla matematiska ber√§kningar. Betygsber√§kningen med alla if/elif-satser f√∂r olika grader var ocks√• ganska rakt p√• sak √§ven om det blev m√•nga rader kod.

‚öôÔ∏è N√§r jag kom till kmom03 och fick till√§mpa funktionskunskaper i Python blev skillnaden dramatisk. Att definiera funktioner med def funktionsnamn(): k√§ndes bekant fr√•n tidigare spr√•k, men Python's s√§tt att hantera return-v√§rden och parametrar hade sina egna nyanser. Jag gl√∂mde return-satsen flera g√•nger i b√∂rjan - speciellt i create_ssn() d√§r jag fick "None" tillbaka innan jag ins√•g vad som saknades. Det som var mest annorlunda var hur smidig och intuitiv modulhanteringen var, √§ven om import-syntaxen kr√§vde lite inl√§rning. Att strukturera koden i main.py f√∂r menyn, marvin1.py f√∂r refaktoriserade funktioner fr√•n kmom02, och marvin2.py f√∂r nya avancerade funktioner f√∂rvandlade helt programmet. Med import marvin1 och import marvin2 kunde jag anv√§nda marvin1.greet() och marvin2.create_ssn() p√• ett naturligt s√§tt, men det som blev lite knepigt var n√§r jag ville √•teranv√§nda calculate_luhna_sum() fr√•n marvin1.py inne i marvin2.py - d√• uppt√§ckte jag skillnaden mellan import marvin1 och from marvin1 import calculate_luhna_sum.

‚úÖ De l√§ttaste uppgifterna i kmom03 var definitivt att konvertera alla gamla funktioner fr√•n kmom02 till separata funktioner i marvin1.py eftersom det mest var copy-paste och l√§gga def framf√∂r, plus lite refactoring f√∂r att ta bort globala variabler. Greet(), celsius_to_fahrenheit(), och points_to_grade() var rakt p√• sak - bara flytta koden fr√•n if-satserna och wrappa dem i funktioner. Validate_ssn() var ocks√• l√§tt att konvertera eftersom logiken redan fanns klar fr√•n kmom02, jag beh√∂vde bara extrahera Luhn-ber√§kningen till calculate_luhna_sum() f√∂r √•teranv√§ndning. R√∂varspr√•ket var roligt och ganska enkelt att implementera som funktion eftersom logiken redan var genomt√§nkt - bara g√• igenom varje bokstav, kolla om det √§r en vokal, och om inte l√§gg till "o" plus lowercase-versionen.

üò§ Men den absolut sv√•raste uppgiften var randomize_string() i marvin2.py som fick mig att fastna i flera timmar. F√∂rst t√§nkte jag att det skulle vara enkelt med random.shuffle(), men d√• ins√•g jag att shuffle() √§ndrar listan p√• plats och jag ville inte anv√§nda listor eftersom vi inte hade l√§rt oss dem ordentligt √§n. Jag f√∂rs√∂kte olika approaches innan jag kom fram till en algoritm d√§r jag skapar en tom result-str√§ng, och sedan i en while-loop v√§ljer ett random index fr√•n den kvarvarande str√§ngen, l√§gger till det tecknet i result, och tar bort det fr√•n temp_string med slicing. Det som tog l√§ngst tid var att f√• till string slicing-delen temp_string[:random_index] + temp_string[random_index + 1:] eftersom jag inte var van vid Python's slicing-syntax och det k√§ndes s√• annorlunda fr√•n andra spr√•k jag jobbat med.

üîç Find_all_indexes() var ocks√• riktigt utmanande p√• ett annat s√§tt. I b√∂rjan f√∂rs√∂kte jag bara anv√§nda string.find() i en loop, men sedan uppt√§ckte jag att index() kastar ValueError n√§r den inte hittar n√•got, vilket faktiskt √§r perfekt f√∂r min while True loop med try/except. Det sv√•ra var att hantera start-positionen korrekt och bygga upp result-str√§ngen med kommatecken mellan indexen - f√∂rst hade jag alltid ett extra kommatecken i b√∂rjan eller slutet, s√• jag fick g√∂ra en if-sats f√∂r f√∂rsta tr√§ffen och sedan l√§gga till komma plus index f√∂r resten. SSN-generering i create_ssn() var utmanande av en tredje anledning eftersom det inte bara handlade om algoritmen utan √§ven att f√∂rst√• hur Luhn-checksumman fungerar i omv√§nd riktning. Jag hade calculate_luhna_sum() fr√•n kmom02, men nu skulle jag generera den sista siffran s√• att summan blev delbar med 10, och formeln (10 - (luhn_sum % 10)) % 10 tog tid att f√∂rst√• och verifiera med olika personnummer.

üîß Det som tog mest tid var faktiskt inte sj√§lva uppgifterna utan att f√• modulerna att fungera tillsammans. I b√∂rjan importerade jag bara import marvin1 i marvin2.py och f√∂rs√∂kte anv√§nda marvin1.calculate_luhna_sum(), men det fungerade inte som f√∂rv√§ntat. Sedan testade jag from marvin1 import * vilket fungerade men k√§ndes fel, och till slut l√§rde jag mig att from marvin1 import calculate_luhna_sum var det r√§tta s√§ttet, fast det tog tid att f√∂rst√• varf√∂r. Main.py blev faktiskt ganska enkel att skriva n√§r jag v√§l hade alla funktioner p√• plats eftersom det bara blev en ren meny-handler med funktionsanrop, mycket cleanare √§n den l√•nga if/elif-kedjan fr√•n kmom02.

üéØ Min tidigare erfarenhet hj√§lpte definitivt med att f√∂rst√• funktionsfl√∂de, parameterhantering och √•teranv√§ndbarhet, men Python's specifika s√§tt att hantera namespaces och modulorganisation var nytt territorium. Det som slog mig var hur mycket mer elegant Python g√∂r vissa saker - string-hantering med inbyggda metoder som index(), random-modulens enkelhet f√∂r SSN-generering, och hur naturligt det k√§nns att organisera funktionalitet i separata moduler. Min st√∂rsta TIL f√∂r dessa kursmomenten √§r hur Python kombinerar v√§lbekanta programmeringskoncept med sina egna eleganta, pythoniska l√∂sningar. Resan fr√•n 180 rader organisk kod till v√§lstrukturerade, √•teranv√§ndbara moduler demonstrerade verkligen kraften i god arkitektur, och Python's rika ekosystem av bibliotek som random, kombinerat med kraftfulla inbyggda string-metoder, g√∂r komplexa uppgifter f√∂rv√•nansv√§rt tillg√§ngliga. Det mest meningsfulla var att uppt√§cka hur tidigare programmeringskunskaper inte bara kunde √∂verf√∂ras till Python, utan faktiskt f√∂rdjupas och f√∂rb√§ttras genom spr√•kets unika filosofi och design.